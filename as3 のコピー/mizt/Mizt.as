package mizt {	import flash.display.Sprite;	import flash.display.Stage;		import flash.events.Event;	import flash.utils.getTimer;	import flash.utils.Dictionary;	import flash.system.ApplicationDomain;	import flash.external.ExternalInterface;// Tweener	import mizt.tweener.*;	import mizt.tweener.properties.ColorShortcuts;//	import mizt.utils.Counter;//    public class Mizt extends Sprite {// Config		private static const USE_SWFADDRESS:Boolean=false;// COMMON		private static var _instance:Mizt;		private var _isPause:Boolean=false;// LAYER		private var _layer:Object;// SCENE		private var _scenes:Object;		private var _crntScene:String = "";		private var _prevScene:String = "";		private var _crntDuration:Number = 0;		private var _isLock:Boolean=false;		private var _waitId:Array = [];		private var _fade:Counter;		private var _fadeIn:Function;		private var _fadeOut:Function;// ENTER_FRAME		private var _isStop:Boolean=true;		private var _enterframeDict:Dictionary=null;		private var _numListeners:int=0;		private var _func:Function=null;		private var _crntTime:Number=0;		private var _prevTime:Number=0;// RESIZE		private var _stage:Stage=null;		private var _resizeDict:Dictionary=null;		private var _resizeListener:int = 0;//// OBJECT_UTILS//		public static function getObjectLength($object:Object):uint {			var total:uint = 0;			for(var name:String in $object) { ++total }			return total;		}    	public static function concatObjects(...args):Object{    		var finalObject:Object = {};    		var currentObject:Object;    		for (var i:int=0; i<args.length; i++){    			currentObject = args[i];    			for (var prop:String in currentObject){    				if(currentObject[prop]==null) delete finalObject[prop]; // delete in case is null    				else finalObject[prop] = currentObject[prop];    			}    		}    		return finalObject;    	}//// CLASS_UTILS//		//public static function traceClassNamae($obj:Object):void { getClassName($obj); }		//public static function getClassName($obj:Object):String{ var arr:Array = (flash.utils.getQualifiedClassName($obj)).split(/::/); return arr[arr.length-1]; }		public static function getClass(str:String):Class { return Class(ApplicationDomain.currentDomain.getDefinition(str)); }//// COMMON//// utils ...		//public static function getVersion():String { return "Mizt 0.26"; }		public static function printError($message:String): void { trace("Error : "+$message); }// setup ...		public static function setup($stage:Stage,$layer:*=null):void { //:Mizt {			if(_instance==null) _instance = new Mizt(), _instance.initialize();			_instance._stage = $stage; // setup 			_instance._stage.align = "TL";			_instance._stage.scaleMode = "noScale"; //StageScaleMode.NO_SCALE;			_instance._stage.tabChildren = false;			//_instance._stage.quality = "Low"; 			// Tweener option			ColorShortcuts.init();			//SoundShortcuts.init();						if($layer==null) {				$stage.addChild(_instance);			}			else {				$layer.addChild(_instance);			}					}// getInstance		public static function getInstance():Mizt { 			if(_instance==null) _instance = new Mizt(), _instance.initialize();			//if(!_stage) { if(stage) _stage = stage; }			return _instance;		}				public static function get $():Mizt { 			if(_instance==null) _instance = new Mizt(), _instance.initialize();			//if(!_stage) { if(stage) _stage = stage; }			return _instance;		}		public function initialize():void {			//trace(getVersion());			_layer  = new Object();			_scenes = new Object();//swfaddress			//if(USE_SWFADDRESS) { SWFAddress.addEventListener(SWFAddressEvent.CHANGE,_instance.onSWFAddressChange); }			_numListeners = 0;			_enterframeDict = new Dictionary(false); // false ? true			_resizeDict     = new Dictionary(false);		}				public static function pause():void {			var me:Mizt = (Mizt.getInstance());			me._isPause = true;			if(me._scenes[me._crntScene]&&(me._scenes[me._crntScene]).hasOwnProperty("pause")) {				me._scenes[me._crntScene].pause();			}			//removeEventListener(Event.ENTER_FRAME,update);		}				public static function resume():void {			var me:Mizt = (Mizt.getInstance());			me._isPause = false;			if(me._scenes[me._crntScene]&&(me._scenes[me._crntScene]).hasOwnProperty("resume")) {				me._scenes[me._crntScene].resume();			}			me._prevTime= getTimer();			//addEventListener(Event.ENTER_FRAME,update);		}		//// RESIZE_MANAGER//		private function onResize(e:Event):void {			var sw:int =  _stage.stageWidth;			var sh:int =  _stage.stageHeight;			for each(_func in _resizeDict) _func(sw,sh); // 登録されている関数を呼ぶ 		}		// change : 11.01.21// (Mizt.getInstance()).addResize(func)    -> Mizt.addResize(func)// (Mizt.getInstance()).removeResize(func) -> Mizt.removeResize(func)		public static function addResize($func:Function):void {						var me:Mizt = (Mizt.getInstance());						if (!me._resizeDict[$func]) {				me._resizeDict[$func] = $func;				if(me._resizeListener==0) {					if(!me._stage) { if(me.stage) me._stage = me.stage; }					if(me._stage) {						me._stage.addEventListener(Event.RESIZE,me.onResize);					}				}				if(!me._stage) { if(me.stage) me._stage = me.stage; }				if(me._stage) {					$func(me._stage.stageWidth,me._stage.stageHeight);				}				++(me._resizeListener);			}		}		public static function removeResize($func:Function):void {					var me:Mizt = (Mizt.getInstance());						if (me._resizeListener>0&&me._resizeDict[$func]) {				--(me._resizeListener);				if(me._resizeListener==0) {					if(!me._stage) { if(me.stage) me._stage = me.stage; }					if(me._stage) me._stage.removeEventListener(Event.RESIZE,me.onResize);				}				delete me._resizeDict[$func];			}		}//// LAYER_MANAGER//		public static function addLayer($dispObj:*,$id:String):void {					var me:Mizt = (Mizt.getInstance());					if(!me._layer[$id]) me._layer[$id] = $dispObj;		}		public static function getLayer($id:String):* {						var me:Mizt = (Mizt.getInstance());			return (me._layer[$id])?me._layer[$id]:null;					}//		public static function addChildLayer($dispObj:*,$id:String):void {			trace("addChildLayer");			var me:Mizt = (Mizt.getInstance());						if(!me._layer[$id]) {				me._layer[$id].addChild($dispObj);			}			else {				if(!me._layer[$id].contains($dispObj)) {					me._layer[$id].addChild($dispObj);				}			}		}		public static function removeChildLayer($dispObj:*,$id:String):void {					var me:Mizt = (Mizt.getInstance());						if(me._layer[$id]&&me._layer[$id].contains($dispObj)) {				//trace("removeChildLayer : " + $dispObj);				me._layer[$id].removeChild($dispObj);			}		}//// SCENE_MANAGER//		public function getCrntScene():String { return _crntScene; }		public function getPrevScene():String { return _prevScene; }		public function isFade():Boolean { return (_fade==null)?false:true; }		public function getFadeTime():Number { return _crntDuration; }//swfaddress		//private function onSWFAddressChange(e:SWFAddressEvent):void {			//if(USE_SWFADDRESS) {				//trace("SWFAddressEvent : \""+(SWFAddress.getValue()).replace("/","")+" \"");				//var tmp:String = (SWFAddress.getValue()).replace("/","");				//if(tmp!=_crntScene) this.gotoScene(tmp);			//}		//}				public static function addScene($scene:*,$id:String):void { 			var me:Mizt = (Mizt.getInstance());			if(!me._scenes[$id]) me._scenes[$id] = $scene 		}				public static function addChildScene($id:String):void {			var me:Mizt = (Mizt.getInstance());			if(me._scenes[$id]&&!me.contains(me._scenes[$id])) {				me.addChild(me._scenes[$id]);				me._scenes[$id].initialize();				//me._scenes[$id].alpha=0;				if(me._isPause) Mizt.pause(); // ポーズ中に再帰で呼び出されたときに			}		}				public static function removeChildScene($id:String):void {			var me:Mizt = (Mizt.getInstance());			if(me._scenes[$id]&&me.contains(me._scenes[$id])) {				me._scenes[$id].finalize(); // 終了処理				me.removeChild(me._scenes[$id]);					}		}						private var fadeOutFunc:Function = null;		private var fadeInFunc:Function = null;				public static function fadeScene($step:Number):void {			var me:Mizt = (Mizt.getInstance());			if(me._fade.update($step)) {				Mizt.removeEnterFrame(Mizt.fadeScene);				if(me._scenes[me._prevScene]) { Mizt.removeChildScene(me._prevScene); }				me._fade = null;				Mizt.gotoSceneComplete();			}			else {				var val:Number = me._fade.getValue();				if(me.fadeOutFunc as Function)  me.fadeOutFunc(1.-val);				if(me.fadeInFunc  as Function)	me.fadeInFunc(val);							}		}				public static function gotoSceneComplete():void {						var me:Mizt = (Mizt.getInstance());						//if(me._scenes[me._crntScene]) me._scenes[me._crntScene].alpha=1; // フェードの為にアルファの値をもとに戻す			me._isLock = false; // ロックの解除						if(me._waitId.length>0) {				Mizt.gotoScene(me._waitId.splice(0,1)[0]); 			} // 待ちがあれば再び処理を開始			else {				if(!me._stage) { if(me.stage) me._stage = me.stage; }				if(me._stage) me._stage.mouseChildren = true; // マウスの回復				else printError("Mizt::gotoSceneComplete | not found stage");				if(me._scenes[me._crntScene]) me._scenes[me._crntScene].dispatchEvent(new Event("FADE_IN"));// swfaddress				//if(USE_SWFADDRESS) { // やっとアドレスを発行(先に発行した方がいい？)					//if(SWFAddress.getValue()!=("/"+_crntScene)) { SWFAddress.setValue("/"+_crntScene); }				//}			}		}		// クロスフェードする場合は二つ目の引数に適当な値を		public static function gotoScene($id:String,$duration:Number=0):void {						var me:Mizt = (Mizt.getInstance());						//trace($id);			// 処理中なので、配列に入れて処理が終わるのを待つ			if(me._isLock) { 				if(me._waitId[me._waitId.length-1] != $id) {					me._waitId.push($id); 				}					return; 			} 			else {				if(me._crntScene==$id) return;			}						if($duration<0) $duration=0;			me._crntDuration = $duration;			me._isLock = true;						if(me._scenes[$id]) { // シーンが登録されているので、遷移を開始																if(!me._stage) { if(me.stage) me._stage = me.stage; }				if(me._stage) me._stage.mouseChildren = false; // とりあえずマウスは切ろう				//else printError("Mizt::gotoScene | not found stage");								if((me._crntScene!=$id)&&(me._crntScene!="")) { // 前のシーンがあるか調べる					me._prevScene = me._crntScene;					me._crntScene = $id;					if($duration==0) Mizt.removeChildScene(me._prevScene); // fadeOut しない場合はシーンを removeChild する				}				else {					me._prevScene = "";					me._crntScene = $id;					// 前のシーンがないのでフェード設定を強制的に切る					//$duration = 0;				}				Mizt.addChildScene(me._crntScene); // シーンを addChild する										// 処理が終わった				if($duration==0) {					Mizt.gotoSceneComplete(); // 終了処理				}				else {					if(me._scenes[me._prevScene]) me._scenes[me._prevScene].dispatchEvent(new Event("FADE_OUT")); // フェードすることを通知する										me._fade = new Counter($duration); // フェードの為にカウンターをまわす					// フェードの関数をアサインする					me.fadeOutFunc = (me._scenes[me._prevScene]&&me._scenes[me._prevScene].hasOwnProperty("fadeOut"))?(me._scenes[me._prevScene].fadeOut):null;					me.fadeInFunc  = (me._scenes[me._crntScene]&&me._scenes[me._crntScene].hasOwnProperty("fadeIn")) ?(me._scenes[me._crntScene].fadeIn):null;					Mizt.addEnterFrame(Mizt.fadeScene);		//				}				}						//trace($id);		}//		private static function update(e:Event):void  {						var me:Mizt = (Mizt.getInstance());						// ポーズ中は処理しない			if(me._isPause) return;			me._crntTime = getTimer(); // 前のフレームとの差分			var _step:Number=(me._crntTime-me._prevTime)*0.001;			me._prevTime=me._crntTime;			for each(me._func in me._enterframeDict) me._func(_step); // 登録されている関数を呼ぶ 		}//		public static function addEnterFrame($func:Function):void {			var me:Mizt = (Mizt.getInstance());			if(!me._enterframeDict[$func]) {				me._enterframeDict[$func] = $func;				if((++(me._numListeners))>=1) {					if(me._isStop) {						me._isStop = false; 						me._prevTime= getTimer();						me.addEventListener(Event.ENTER_FRAME,Mizt.update);					}				}			}			//else trace("\t"+int($func)+" is already registered ");		}//				public static function removeEnterFrame($func:Function):void {			var me:Mizt = (Mizt.getInstance());			if(me._enterframeDict[$func]) {				//trace("\tremoveEnterFrame : "+$func+" : "+me._numListeners);				delete  me._enterframeDict[$func];				if((--(me._numListeners))<=0){					if(!me._isStop) {						me._isStop = true;						me.removeEventListener(Event.ENTER_FRAME,Mizt.update);					}				}			}		}//// Tweener++// 		private static var _isStopTweening:Boolean = false;			private static var _tweenEngineExists:Boolean = false;		// Whether or not the engine is currently running		private static var _initedTween:Boolean = false;			// Whether or not the class has been initiated		private static var _tweenTime:Number;						// The current time. This is generic for all tweenings for a "time grid" based update		private static var _tweenList:Array;						// List of active tweens		private static var _transitionList:Object;					// List of "pre-fetched" transition functions		private static var _specialPropList:Object;					// List of special prop		private static var _specialPropModifierList:Object;			// List of special property modifiers		private static var _specialPropSplitterList:Object;			// List of special property splitters		public  static var _tweenAutoOverwrite:Boolean = true;		// If true, auto overwrite on new tweens is on unless declared as false		//public static function specialPropParse() {}		// Mizt.addTween(mc,{});		public static function addTween($target:Object=null,$params:Object=null):Boolean {			if (!$target) return false;			var i:Number, j:Number, propName:String, len:int;			var rTargets:Array = ($target is Array)?$target.concat():[$target];			var tweenProp:Object = TweenList.makePropChain($params);			if (!_initedTween) 	initTween();			if (!_tweenEngineExists) startEngine();			var rTime:Number  = (isNaN(tweenProp.time )?0:tweenProp.time );			var rDelay:Number = (isNaN(tweenProp.delay)?0:tweenProp.delay);			var rProp:Array = new Array();			var restrictedWords:Object = {overwrite:true, time:true, delay:true, skipUpdates:true, transition:true, transitionParams:true, onStart:true, onUpdate:true, onComplete:true, onOverwrite:true, onError:true, rounded:true, onStartParams:true, onUpdateParams:true, onCompleteParams:true, onOverwriteParams:true, onStarttarget:true, onUpdatetarget:true, onCompletetarget:true, onOverwritetarget:true, onErrortarget:true};			var modifiedProp:Object = new Object();			for(propName in tweenProp) {				if(!restrictedWords[propName]) {									// 登録されている SplitterList　を個々の　PropList　に振り分ける					if(_specialPropSplitterList[propName]) {						var splitProp:Array 	= _specialPropSplitterList[propName].splitValues(tweenProp[propName], _specialPropSplitterList[propName].parameters);						var splitPropLen:uint	= splitProp.length;						for (i=0; i<splitPropLen; i++) {														// 再帰で子供を走査							if (_specialPropSplitterList[splitProp[i].name]) {																var splitPropChildren:Array 	= _specialPropSplitterList[splitProp[i].name].splitValues(splitProp[i].value, _specialPropSplitterList[splitProp[i].name].parameters);																var splitPropChildrenLen:uint   = splitPropChildren.length;																for (j=0;j<splitPropChildrenLen;j++) {									rProp[splitPropChildren[j].name] = {valueStart:undefined, valueComplete:splitPropChildren[j].value, isSpecialProperty:false};									}							} 							else {								rProp[splitProp[i].name]={valueStart:undefined,valueComplete:splitProp[i].value,isSpecialProperty:false};							}						}					} 					else if (_specialPropModifierList[propName] != undefined) {						var tempModifiedProp:Array = _specialPropModifierList[propName].modifyValues(tweenProp[propName]);						for (i=0;i<tempModifiedProp.length;i++) {							modifiedProp[tempModifiedProp[i].name] = {modifierParameters:tempModifiedProp[i].parameters, modifierFunction:_specialPropModifierList[propName].getValue};						}					} 					else {						rProp[propName] = {valueStart:undefined, valueComplete:tweenProp[propName]};					}				}			}			for (propName in rProp) {				// スペシャルプロパティであることを設定				if(_specialPropList[propName]!=undefined) rProp[propName].isSpecialProperty=true;				else if(rTargets[0][propName]==undefined) printError("The property '"+propName+"' doesn't seem to be a normal object property of "+String(rTargets[0])+" or a registered special property.");			}			for(propName in modifiedProp) {				if(rProp[propName]!=undefined) {					rProp[propName].modifierParameters = modifiedProp[propName].modifierParameters;					rProp[propName].modifierFunction   = modifiedProp[propName].modifierFunction;				}			}			// トランジションの設定。　デフォルトは　easeoutexpo			var rTransition:Function = (typeof(tweenProp.transition)=="string")?(_transitionList[(tweenProp.transition.toLowerCase())]):(tweenProp.transition);			if (!Boolean(rTransition)) rTransition = _transitionList["easeoutexpo"];			len = rTargets.length;			for (i=0;i<len;i++) {				var nTween:TweenList = new TweenList(rTargets[i],(_tweenTime+rDelay),(_tweenTime+rDelay+rTime),rTransition,tweenProp.transitionParams);				var nProp:Object = new Object(); // Makes a copy of the prop				for (propName in rProp) nProp[propName] = new TweenPropInfo(rProp[propName].valueStart,rProp[propName].valueComplete,rProp[propName].valueComplete,rProp[propName].arrayIndex,{},rProp[propName].isSpecialProperty,rProp[propName].modifierFunction,rProp[propName].modifierParameters);				nTween.setup(nProp,tweenProp);				if ((tweenProp.overwrite==undefined)?(_tweenAutoOverwrite):(tweenProp.overwrite)) removeTweensByTime(nTween.target,nTween.prop,nTween.timeStart,nTween.timeComplete); 				_tweenList.push(nTween);				if((rTime==0)&&(rDelay==0)) {					var myT:uint =_tweenList.length-1;					updateTweenByIndex(myT);					removeTweenByIndex(myT);				}			}			return true;		}		public static function removeTweensByTime($target:Object, $prop:Object, $timeStart:Number, $timeComplete:Number):Boolean {			var propName:String;			var removed:Boolean = false;			var removedLocally:Boolean;			var len:uint = _tweenList.length;			for (var i:uint=0; i<len; i++) {				if (_tweenList[i]&&($target)==_tweenList[i].target) {					if ($timeComplete>_tweenList[i].timeStart&&$timeStart<_tweenList[i].timeComplete) { // Same object...						removedLocally = false; // New time should override the old one...						for (propName in _tweenList[i].prop) {							if (Boolean($prop[propName])) {								if (Boolean(_tweenList[i].onOverwrite)) { // Same object, same property, Finally, remove this old tweening and use the new one									var eventtarget:Object = Boolean(_tweenList[i].onOverwritetarget)?(_tweenList[i].onOverwritetarget):(_tweenList[i].target);									try { _tweenList[i].onOverwrite.apply(eventtarget,_tweenList[i].onOverwriteParams); } 									catch(err:Error) { handleError(_tweenList[i],err,"onOverwrite"); }								}								_tweenList[i].prop[propName] = undefined;								delete _tweenList[i].prop[propName];								removedLocally = true;								removed = true;							}						}						if (removedLocally) { // Verify if this can be deleted							if (Mizt.getObjectLength(_tweenList[i].prop)==0) removeTweenByIndex(i);						}					}				}			}			return removed;		}		public static function removeTweens($target:Object, ...args):Boolean {			// Create the property list			var prop:Array = new Array();			var len:int=args.length;			for (var i:uint=0;i<len;i++) {				if (typeof(args[i])=="string"&&prop.indexOf(args[i])==-1){					if (_specialPropSplitterList[args[i]]){						var sps:SpecialPropSplitter = _specialPropSplitterList[args[i]]; //special property, get splitter array first						var specialProps:Array = sps.splitValues($target, null);						for (var j:uint=0; j<specialProps.length; j++) prop.push(specialProps[j].name);					} 					else {						prop.push(args[i]);					}				}			}			return affectTweens($target,prop,removeTweenByIndex); // Call the affect function on the specified prop		}		public static function removeAllTweens():Boolean {			if (!_tweenList) return false;			var removed:Boolean = false;			var len:int=_tweenList.length;			for (var i:uint=0;i<len;i++) { removeTweenByIndex(i); removed=true; }			return removed;		}		private static function affectTweens($target:Object,$prop:Array,$affectFunction:Function):Boolean {			var affected:Boolean = false;			if (!_tweenList) return false;			var tweenLen:int = _tweenList.length;			for (var i:uint =0; i<tweenLen; i++) {				if (_tweenList[i]&&_tweenList[i].target==$target) {					if ($prop.length==0) {						$affectFunction(i); // Can affect everything						affected = true;					} 					else {						var affectedProp:Array = new Array(); // Must check whether this tween must have specific prop affected						var propLen:int = $prop.length						// copy prop						for(var j:uint=0; j<propLen; j++) {							if (Boolean(_tweenList[i].prop[$prop[j]])) {								affectedProp.push($prop[j]);							}						}						if(affectedProp.length>0) {							var objectprop:uint = Mizt.getObjectLength(_tweenList[i].prop);							if (objectprop == affectedProp.length) { // The list of prop is the same as all prop, so affect it all								$affectFunction(i);								affected = true;							} 							else {								// The prop are mixed, so split the tween and affect only certain specific prop								var slicedTweenIndex:uint = splitTweens(i,affectedProp); 								$affectFunction(slicedTweenIndex);								affected = true;							}						}					}				}			}			return affected;		}		public static function splitTweens($tween:Number,$prop:Array):uint {			var i:uint;			var len:int;			var propName:String;			var originalTween:TweenList = _tweenList[$tween]; // First, duplicates			var newTween:TweenList 		= originalTween.clone(false);						// Removes the specified prop from the old one			len = $prop.length;			for (i=0; i<len; i++) {				propName = $prop[i];				// (original) tween に propName というプロパティがない場合はそのプロパティを削除 				if (Boolean(originalTween.prop[propName])) {					originalTween.prop[propName] = undefined;					delete originalTween.prop[propName];				}			}			// Removes the unspecified prop from the new one			var found:Boolean;			for (propName in newTween.prop) {				found = false;				len = $prop.length;				for (i=0;i<len;i++) {					if ($prop[i]==propName) { found = true; break; }				}				if (!found) {					newTween.prop[propName] = undefined;					delete newTween.prop[propName];				}			}			// If there are empty property lists, a cleanup is done on the next updateTweens() cycle			_tweenList.push(newTween);			return (_tweenList.length-1);		}		private static function updateTweens():Boolean {			if (_tweenList.length==0) return false;			var len:int = _tweenList.length;			while(len--) {				if(_tweenList[len]) { //if(_tweenList[len]==undefined) {					if(!updateTweenByIndex(len)) removeTweenByIndex(len);					if(!_tweenList[len]) removeTweenByIndex(len,true);				}			}			return true;		}			public static function removeTweenByIndex($tweenIndex:int,$finalRemoval:Boolean=false):Boolean {			_tweenList[$tweenIndex] = null;			if ($finalRemoval) _tweenList.splice($tweenIndex,1);			return true;		}// update		private static function updateTweenByIndex ($tweenIndex:int):Boolean {			var tTweening:TweenList = _tweenList[$tweenIndex];	// Shortcut to this tweening			if (tTweening==null||!tTweening.target) return false;			var isOver:Boolean = false;				var propName:String;				// Property name, used in loops			var tTarget:Object;				// Current target			var cTime:Number = _tweenTime; //getCurrentTweeningTime(tTweening);			var tProp:Object;			// Property being checked			if(cTime >= tTweening.timeStart) {				tTarget = tTweening.target;				if(cTime>=tTweening.timeComplete) { isOver = true;}				// まだ Tween を開始していないので、				if(!tTweening.hasStarted) {					// onStart があれば　onStartParams　を引数に実行					if (Boolean(tTweening.onStart)) {						try { tTweening.onStart.apply((Boolean(tTweening.onStartScope)?tTweening.onStartScope:tTarget),tTweening.onStartParams); } 						catch(err:Error) { handleError(tTweening,err,"onStart"); }					}					var pv:Number;					// プロパティを走査					for (propName in tTweening.prop) {						if (tTweening.prop[propName].isSpecialProperty) { // スペシャルプロパティがある場合							if (Boolean(_specialPropList[propName].preProcess)) { // スペシャルプロパティのプリプロセスが必要ある場合								tTweening.prop[propName].valueComplete = _specialPropList[propName].preProcess(tTarget, _specialPropList[propName].parameters, tTweening.prop[propName].originalValueComplete, tTweening.prop[propName].extra);							}							pv = _specialPropList[propName].getValue(tTarget, _specialPropList[propName].parameters, tTweening.prop[propName].extra);						} 						else {							pv = tTarget[propName]; // Directly read property						}						tTweening.prop[propName].valueStart = isNaN(pv) ? tTweening.prop[propName].valueComplete : pv;					}					tTweening.hasStarted = true;				}////	calc//				var nv:Number; // New value for each property				var  t:Number;	// current time (frames, seconds)				var  d:Number; // duration (frames, seconds)				for (propName in tTweening.prop) {					tProp = tTweening.prop[propName];					if (isOver) { nv = tProp.valueComplete; } // Tweening time has finished, just set it to the final value					else {								t = cTime - tTweening.timeStart;						d = tTweening.timeComplete - tTweening.timeStart;						if (tProp.hasModifier) { // Modified							nv = tTweening.transition(t,0,1,d,tTweening.transitionParams); // begin 0, change 1 ... , 0 to 1							nv = tProp.modifierFunction(tProp.valueStart,tProp.valueComplete,nv,tProp.modifierParameters);						} 						else { // Normal update							nv = tTweening.transition(t,(tProp.valueStart),tProp.valueComplete-tProp.valueStart,d,tTweening.transitionParams);						}					}					// 丸め込みが必要なら					if (tTweening.rounded) nv = Math.round(nv);					if (tProp.isSpecialProperty) { // スペシャルプロパティなのでセッター経由で						_specialPropList[propName].setValue(tTarget, nv, _specialPropList[propName].parameters, tTweening.prop[propName].extra);					} 					else { // ダイレクトにプロパティを変更						tTarget[propName] = nv;					}				}				// onUpdate メソッドが定義されているなら				if (Boolean(tTweening.onUpdate)) {					try { tTweening.onUpdate.apply((Boolean(tTweening.onUpdateScope)?tTweening.onUpdateScope:tTarget),tTweening.onUpdateParams); } 					catch(err:Error) { handleError(tTweening,err,"onUpdate"); }				}								// onComplete メソッドが定義されているなら				if (isOver&&Boolean(tTweening.onComplete)) {					try { tTweening.onComplete.apply((Boolean(tTweening.onCompleteScope)?tTweening.onCompleteScope:tTarget),tTweening.onCompleteParams); } 					catch(err:Error) { handleError(tTweening,err,"onComplete"); }				}				return (!isOver);			}			return true; // On delay, hasn't started, so returns true		}		public static function initTween(...rest):void {			_initedTween = true;			_transitionList = new Object(); 		// Registers all default equations			initEquations();			_specialPropList = new Object(); 	// Registers all default special prop			_specialPropModifierList = new Object();			_specialPropSplitterList = new Object();		}		public static function registerSpecialProperty($name:String,$getFunc:Function,$setFunc:Function,$parameters:Array=null,$preProcessFunc:Function=null):void {			if (!_initedTween) initTween();			var sp:SpecialProp = new SpecialProp($getFunc,$setFunc,$parameters,$preProcessFunc);			_specialPropList[$name] = sp;		}		public static function registerSpecialPropertyModifier($name:String,$modifyFunction:Function,$getFunction:Function): void {			if (!_initedTween) initTween();			_specialPropModifierList[$name] = new SpecialPropModifier($modifyFunction,$getFunction);		}		public static function registerSpecialPropertySplitter($name:String,$splitFunction:Function,$parameters:Array = null): void {			if (!_initedTween) initTween();			_specialPropSplitterList[$name] = new SpecialPropSplitter($splitFunction, $parameters);		}		private static function startEngine():void {			_tweenEngineExists = true;			_tweenList = new Array();			Mizt.addEnterFrame(Mizt.calcTweens);			_tweenTime = 0; // getTimer()*0.001;		}		private static function stopEngine():void {			_tweenEngineExists = false;			_tweenList = null;			_tweenTime = 0;			Mizt.removeEnterFrame(Mizt.calcTweens);		}		public static function pauseAllTweens():void  { if(_isStopTweening)  _isStopTweening = true; }		public static function resumeAllTweens():void { if(!_isStopTweening) _isStopTweening = false; }		public static function calcTweens($_step:Number):void {			if(!_isStopTweening) {				_tweenTime += $_step;				if (!updateTweens()) stopEngine();			}		}		public static function isTweening($target:Object):Boolean {			if(_tweenList) {				var len:uint = _tweenList.length;				for(var i:uint=0; i<len; i++) if(_tweenList[i]&&(_tweenList[i].target==$target)) return true;			}			return false;		}		public static function getTweens($target:Object):Array {			var tList:Array = [];			if(_tweenList) {				var pName:String;				for(var i:uint = 0; i<_tweenList.length; i++) {					if(_tweenList[i]&&(_tweenList[i].target==$target)) {						for(pName in _tweenList[i].prop) tList.push(pName);					}				}			}			return tList;		}		public static function getTweenCount($target:Object):Number {			var cnt:Number = 0;			if(_tweenList) {					var len:uint = _tweenList.length;				for(var i:uint = 0; i<len; i++) if((_tweenList[i])&&(_tweenList[i].target==$target)) cnt+=Mizt.getObjectLength(_tweenList[i].prop);			}			return cnt;		}        private static function handleError($tweening:TweenList,$error:Error,$callBackName:String):void {            if (Boolean($tweening.onError)&&($tweening.onError is Function)){ // do we have an error handler?				var eventTarget:Object = Boolean($tweening.onErrorScope)?($tweening.onErrorScope):($tweening.target);  // yup, there's a handler. Wrap this in a try catch in case the onError throws an error itself.                try { $tweening.onError.apply(eventTarget,[$tweening.target,$error]); } 				catch (metaError:Error){ printError("[Tweener] "+String($tweening.target)+" raised an error while executing the 'onError' handler. Original error:\n "+$error.getStackTrace()+"\nonError error: "+metaError.getStackTrace()); }            } 			else {                if (!Boolean($tweening.onError)){ // no handler, simply trace the stack trace:					printError("[Tweener] "+String($tweening.target)+" raised an error while executing the '"+$callBackName+"'handler. \n"+$error.getStackTrace());                }            }        }//// setup transition list//		public static function registerTransition($name:String,$func:Function):void {			if (!_initedTween) initTween();			_transitionList[$name] = $func;		}		public static function initEquations():void {			Mizt.registerTransition("easenone",			easeNone);			Mizt.registerTransition("linear",			easeNone);					Mizt.registerTransition("easeinquad",		easeInQuad);				Mizt.registerTransition("easeoutquad",		easeOutQuad);				//Mizt.registerTransition("easeinoutquad",	easeInOutQuad);			//Mizt.registerTransition("easeoutinquad",	easeOutInQuad);			Mizt.registerTransition("easeincubic",		easeInCubic);			Mizt.registerTransition("easeoutcubic",		easeOutCubic);			//Mizt.registerTransition("easeinoutcubic",	easeInOutCubic);			//Mizt.registerTransition("easeoutincubic",	easeOutInCubic);			Mizt.registerTransition("easeinquart",		easeInQuart);			Mizt.registerTransition("easeoutquart",		easeOutQuart);			//Mizt.registerTransition("easeinoutquart",	easeInOutQuart);			//Mizt.registerTransition("easeoutinquart",	easeOutInQuart);			Mizt.registerTransition("easeinquint",		easeInQuint);			Mizt.registerTransition("easeoutquint",		easeOutQuint);			//Mizt.registerTransition("easeinoutquint",	easeInOutQuint);			//Mizt.registerTransition("easeoutinquint",	easeOutInQuint);			Mizt.registerTransition("easeinsine",		easeInSine);			Mizt.registerTransition("easeoutsine",		easeOutSine);			//Mizt.registerTransition("easeinoutsine",	easeInOutSine);			//Mizt.registerTransition("easeoutinsine",	easeOutInSine);			Mizt.registerTransition("easeincirc",		easeInCirc);			Mizt.registerTransition("easeoutcirc",		easeOutCirc);			//Mizt.registerTransition("easeinoutcirc",	easeInOutCirc);			//Mizt.registerTransition("easeoutincirc",	easeOutInCirc);			Mizt.registerTransition("easeinexpo",		easeInExpo);					Mizt.registerTransition("easeoutexpo", 		easeOutExpo);					//Mizt.registerTransition("easeinoutexpo", 	easeInOutExpo);					//Mizt.registerTransition("easeoutinexpo", 	easeOutInExpo);			Mizt.registerTransition("easeinelastic", 	easeInElastic);					Mizt.registerTransition("easeoutelastic", 	easeOutElastic);				//Mizt.registerTransition("easeinoutelastic", easeInOutElastic);				//Mizt.registerTransition("easeoutinelastic", easeOutInElastic);			Mizt.registerTransition("easeinback", 		easeInBack);					Mizt.registerTransition("easeoutback", 		easeOutBack);					//Mizt.registerTransition("easeinoutback", 	easeInOutBack);					//Mizt.registerTransition("easeoutinback", 	easeOutInBack);			Mizt.registerTransition("easeinbounce", 	easeInBounce);					Mizt.registerTransition("easeoutbounce", 	easeOutBounce);					//Mizt.registerTransition("easeinoutbounce", 	easeInOutBounce);				//Mizt.registerTransition("easeoutinbounce", 	easeOutInBounce);		}		public static function easeNone(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number 		{ return c*(t/=d)*t+b; }				public static function easeInQuad(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number		{ return c*(t/=d)*t+b; }		public static function easeOutQuad(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number	{ return -c*(t/=d)*(t-2)+b; }		//public static function easeInOutQuad(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number	{ return ((t/=d*.5)<1)?(c*.5*t*t+b):(-c*.5*((--t)*(t-2)-1)+b); }		//public static function easeOutInQuad(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number	{ return (t<d*.5)?(easeOutQuad(t*2,b,c*.5,d,p)):(easeInQuad((t*2)-d,b+c*.5,c*.5,d,p)); }		public static function easeInCubic(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number	{ return c*(t/=d)*t*t+b; }		public static function easeOutCubic(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number	{ return c*((t=t/d-1)*t*t+1)+b; }		//public static function easeInOutCubic(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number	{ return ((t/=d*.5)<1)?(c*.5*t*t*t+b):(c*.5*((t-=2)*t*t+2)+b); }		//public static function easeOutInCubic(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number	{ return (t<d*.5)?(easeOutCubic(t*2,b,c*.5,d,p)):(easeInCubic((t*2)-d,b+c*.5,c*.5,d,p)); }		public static function easeInQuart(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number 	{ return c*(t/=d)*t*t*t+b; }		public static function easeOutQuart(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number 	{ return -c*((t=t/d-1)*t*t*t-1)+b; }		//public static function easeInOutQuart(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number	{ return ((t/=d*.5)<1)?(c/2*t*t*t*t+b):(-c*.5*((t-=2)*t*t*t-2)+b); }		//public static function easeOutInQuart(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number { return (t<d*.5)?(easeOutQuart(t*2,b,c*.5,d,p)):(easeInQuart((t*2)-d,b+c*.5,c*.5,d,p)); }		public static function easeInQuint(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number 	{ return c*(t/=d)*t*t*t*t+b; }		public static function easeOutQuint(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number 	{ return c*((t=t/d-1)*t*t*t*t+1)+b; }		//public static function easeInOutQuint(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number { return ((t/=d*.5)<1)?(c*.5*t*t*t*t*t+b):(c*.5*((t-=2)*t*t*t*t+2)+b); }		//public static function easeOutInQuint(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number { return (t<d*.5)?(easeOutQuint(t*2,b,c/2,d,p)):(easeInQuint((t*2)-d,b+c*.5,c*.5,d,p)); }		public static function easeInSine(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number 	{ return -c*Math.cos(t/d*(Math.PI*.5))+c+b; }		public static function easeOutSine(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number 	{ return c*Math.sin(t/d*(Math.PI*.5))+b; }		//public static function easeInOutSine(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number 	{ return -c*.5*(Math.cos(Math.PI*t/d)-1)+b; }		//public static function easeOutInSine(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number 	{ return (t<d*.5)?(easeOutSine(t*2,b,c*.5,d,p)):(easeInSine((t*2)-d,b+c*.5,c*.5,d,p)); }		public static function easeInExpo(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number  	{ return (t==0)?b:c*Math.pow(2,10*(t/d-1))+b-c*0.001; }		public static function easeOutExpo(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number 	{ return (t==d)?b+c:c*1.001*(-Math.pow(2,-10*t/d)+1)+b; }		/*		public static function easeInOutExpo(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number  {			if (t==0) return b;			if (t==d) return b+c;			if ((t/=d*.5)<1) return c*.5*Math.pow(2,10*(t-1))+b-c*0.0005;			return c*.5*1.0005*(-Math.pow(2,-10*--t)+2)+b;		}		public static function easeOutInExpo(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number {			return (t<d/2)?(easeOutExpo(t*2,b,c*.5,d,p)):(easeInExpo((t*2)-d,b+c*.5,c*.5,d,p));		}		*/		public static function easeInCirc(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number 	{ return -c*(Math.sqrt(1-(t/=d)*t)-1)+b; }		public static function easeOutCirc(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number 	{ return c*Math.sqrt(1-(t=t/d-1)*t)+b; }		//public static function easeInOutCirc(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number 	{ return ((t/=d*.5)<1)?(-c*.5*(Math.sqrt(1-t*t)-1)+b):(c*.5*(Math.sqrt(1-(t-=2)*t)+1)+b); }		//public static function easeOutInCirc(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number  { return (t<d/2)?(easeOutCirc (t*2,b,c*.5,d,p)):(easeInCirc((t*2)-d,b+c*.5,c*.5,d,p)); }		public static function easeInElastic(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number  {			if (t==0) return b;			if ((t/=d)==1) return b+c;			var q:Number=!Boolean(p)||isNaN(p.period)?d*.3:p.period;			var s:Number;			var a:Number=!Boolean(p)||isNaN(p.amplitude)?0:p.amplitude;			if (!Boolean(a)||a< Math.abs(c)) { a=c; s=q*.25; }			else { s=q/(2*Math.PI)*Math.asin(c/a); }			return -(a*Math.pow(2,10*(t-=1))*Math.sin((t*d-s)*(2*Math.PI)/q))+b;		}		public static function easeOutElastic(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number {			if (t==0) return b;			if ((t/=d)==1) return b+c;			var q:Number=!Boolean(p)||isNaN(p.period)?d*.3:p.period;			var s:Number;			var a:Number=!Boolean(p)||isNaN(p.amplitude)?0:p.amplitude;			if (!Boolean(a)||a< Math.abs(c)) { a=c; s=q*.25; }			else { s=q/(2*Math.PI)*Math.asin(c/a); }			return (a*Math.pow(2,-10*t)*Math.sin((t*d-s)*(2*Math.PI)/q)+c+b);		}		/*		public static function easeInOutElastic(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number {			if (t==0) return b;			if ((t/=d*.5)==2) return b+c;			var q:Number=!Boolean(p)||isNaN(p.period)?d*(.3*1.5):p.period;			var s:Number;			var a:Number=!Boolean(p)||isNaN(p.amplitude)?0:p.amplitude;			if (!Boolean(a)||a<Math.abs(c)) { a=c; s=q*.25; } 			else { s =q/(2*Math.PI)*Math.asin (c/a); }			return (t<1)?(-.5*(a*Math.pow(2,10*(t-=1))*Math.sin((t*d-s)*(2*Math.PI)/q))+b):(a*Math.pow(2,-10*(t-=1))*Math.sin((t*d-s)*(2*Math.PI)/q)*.5+c+b);		}		public static function easeOutInElastic(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number {	return (t<d*.5)?(easeOutElastic(t*2,b,c*.5,d,p)):(easeInElastic((t*2)-d,b+c*.5,c*.5,d,p)); }		*/		public static function easeInBack(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number {			var s:Number = (!Boolean(p)||isNaN(p.overshoot))?1.70158:p.overshoot;			return c*(t/=d)*t*((s+1)*t-s)+b;		}		public static function easeOutBack(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number {			var s:Number = (!Boolean(p)||isNaN(p.overshoot))?1.70158:p.overshoot;			return c*((t=t/d-1)*t*((s+1)*t+s)+1)+b;		}		/*		public static function easeInOutBack(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number {			var s:Number = (!Boolean(p)||isNaN(p.overshoot))?1.70158:p.overshoot;			return ((t/=d*.5)<1)?(c*.5*(t*t*(((s*=(1.525))+1)*t-s))+b):(c*.5*((t-=2)*t*(((s*=(1.525))+1)*t+s)+2)+b);		}		public static function easeOutInBack(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number	{ return (t<d*.5)?(easeOutBack(t*2,b,c*.5,d,p)):(easeInBack((t*2)-d,b+c*.5,c*.5,d,p)); }		*/		public static function easeInBounce(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number	{ return c-easeOutBounce (d-t,0,c,d)+b; }		public static function easeOutBounce(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number	{			if ((t/=d)<(1/2.75)) 	return c*(7.5625*t*t)+b;			else if(t<(2/2.75))		return c*(7.5625*(t-=(1.5/2.75))*t+.75)+b;			else if(t<(2.5/2.75))	return c*(7.5625*(t-=(2.25/2.75))*t+.9375)+b;			else 					return c*(7.5625*(t-=(2.625/2.75))*t+.984375)+b;		}		/*		public static function easeInOutBounce(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number { return (t<d*.5)?(easeInBounce(t*2,0,c,d)*.5+b):(easeOutBounce(t*2-d,0,c,d)*.5+c*.5+b); }		public static function easeOutInBounce(t:Number,b:Number,c:Number,d:Number,p:Object=null):Number { return (t<d*.5)?(easeOutBounce(t*2,b,c*.5,d,p)):(easeInBounce((t*2)-d,b+c*.5,c*.5,d,p)); }		*///// end Tweener//    }};