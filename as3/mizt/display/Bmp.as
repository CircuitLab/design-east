package mizt.display {//package {    import flash.display.Sprite;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.PixelSnapping;	import flash.display.IBitmapDrawable;	import flash.geom.Matrix;	import flash.geom.Rectangle;	import flash.geom.Point;		    public class Bmp extends Sprite {				private var isInit:Boolean = false;				private var _debugLayer:Sprite;		private var _originalWidth:int,_originalHeight:int;				private var _type:String="TL";		private var _w:Sprite=null;		private var _wrapper:Sprite=null;		private var _container:Sprite=null;						private var _hitAera:Sprite = null;						//private var _border:Sprite=null;		private var _bitmap:Bitmap=null;		protected var _bitmapData:BitmapData=null;				private var _manualPosition:Array = [0,0];				public override function get width():Number { return _originalWidth }		public override function set width($f:Number):void {}		public override function get height():Number { return _originalHeight }		public override function set height($f:Number):void {}				public function set scale($f:Number):void {  scaleX = $f,scaleY = $f;  update(); }  		public function get scale():Number { return scaleX; }		public override function get scaleX():Number { return _bitmap.scaleX; }		public override function set scaleX($f:Number):void { _bitmap.scaleX=$f; update(); }		public override function get scaleY():Number { return _bitmap.scaleY; }		public override function set scaleY($f:Number):void { _bitmap.scaleY=$f; update(); }				public override function get rotation():Number { return _w.rotation; }		public override function set rotation($f:Number):void { _w.rotation=$f; } //update(); }						public function Bmp($src:IBitmapDrawable=null,$width:uint=0,$height:uint=0,$transparent:Boolean=true,$fillColor:uint=0x0) {												_w = new Sprite();			_wrapper = new Sprite();			_container = new Sprite();						this.addChild(_w);			_w.addChild(_wrapper);			_wrapper.addChild(_container);						if($src==null) {				if($width>0&&$height>0) {					_bitmapData = new BitmapData($width,$height,$transparent,$fillColor);					_bitmap = new Bitmap(_bitmapData,PixelSnapping.ALWAYS,false);					_container.addChild(_bitmap);				}			}			else if($src is Bitmap) {				_bitmap = Bitmap($src);				_bitmapData = _bitmap.bitmapData;				_container.addChild(_bitmap);				smoothing(true);							}			else if($src is BitmapData) {				_bitmapData = BitmapData($src);				_bitmap = new Bitmap(_bitmapData);				_container.addChild(_bitmap);				smoothing(true);			}			else if($src is Sprite) {				_bitmapData = new BitmapData(Sprite($src).width,Sprite($src).height,false,0xFFFFFF);				_bitmapData.draw($src);				_bitmap = new Bitmap(_bitmapData);				_container.addChild(_bitmap);			}												_originalWidth = _bitmap.width, _originalHeight = _bitmap.height;			_debugLayer = new Sprite();									_wrapper.x = -_bitmap.width>>1;			_wrapper.y = -_bitmap.height>>1;						_w.x = _bitmap.width>>1;			_w.y = _bitmap.height>>1;						//_hitAera = new Sprite(); 			//_container.addChild(_hitAera);					}						// setHitArea({type:"rect",x:0,y:0,w:10,h:10});		// setHitArea({type:"circle",x:0,y:0,r:10});				public function setHitArea($obj:Object=null):void {			if($obj) {								_hitAera.graphics.clear();				_hitAera.graphics.beginFill(0xFF000000,0.9);				if($obj["type"]=="rect") {					_hitAera.graphics.drawRect($obj["x"],$obj["y"],$obj["w"],$obj["h"]);				}				else if($obj["type"]=="circle") {					_hitAera.graphics.drawCircle($obj["x"],$obj["y"],$obj["r"]);				} 				_hitAera.graphics.endFill();				this.hitArea = _hitAera;			}			else {				this.hitArea = null;			}		}						private function update():void {			switch(_type) {				case "TOP" : case "T" : _container.x = (_originalWidth>>1)*(1.0-scaleX); _container.y = 0; break;				case "TOP_RIGHT" : case "TR" : _container.x = (_originalWidth)*(1.0-scaleX); _container.y = 0; break;				case "LEFT" : case "L" : _container.x = 0; _container.y = (_originalHeight>>1)*(1.0-scaleY); break;				case "CENTER" : case "C" : _container.x = (_originalWidth>>1)*(1.0-scaleX); _container.y = (_originalHeight>>1)*(1.0-scaleY); break;				case "RIGHT" : case "R" : _container.x = (_originalWidth)*(1.0-scaleX); _container.y = (_originalHeight>>1)*(1.0-scaleY); break;				case "BOTTOM_LEFT" : case "BL" : _container.x = 0; _container.y = (_originalHeight)*(1.0-scaleY); break;				case "BOTTOM" : case "B" : _container.x = (_originalWidth>>1)*(1.0-scaleX); _container.y = (_originalHeight)*(1.0-scaleY); break;				case "BOTTOM_RIGHT" : case "BR" : _container.x = (_originalWidth)*(1.0-scaleX); _container.y = (_originalHeight)*(1.0-scaleY); break;				// special "MANUAL"				case "MANUAL" :					//trace("MANUAL");					_container.x = (_originalWidth>>1)*(1.0-scaleX); 					_container.y = (_originalHeight>>1)*(1.0-scaleY);					_container.x -= _manualPosition[0]*(scaleX); 					_container.y -= _manualPosition[1]*(scaleY);					_container.x += _manualPosition[0]; 					_container.y += _manualPosition[1];				break;				// "TOP_LEFT" or "TL" or ...				default : _container.x = 0, _container.y = 0; break;			}				}				public function setAlignWithPosition($x:int,$y:int,$debug:Boolean=false):void {			_type = "MANUAL";			_manualPosition[0] = $x-(_originalWidth>>1);			_manualPosition[1] = $y-(_originalHeight>>1);			// debug			if($debug) {				with(_debugLayer.graphics) {					clear();					lineStyle(0,0x0,0.2);					drawRect(0,0,_originalWidth,_originalHeight);					lineStyle(0,0x00FFFF,0.5);					moveTo($x,0),lineTo($x,_originalHeight);					moveTo(0,$y),lineTo(_originalWidth,$y);				}			}											}				public function setDebug($debug:Boolean=true):void {						with(_debugLayer.graphics) {				clear();				lineStyle(0,0x0,0.2);				drawRect(0,0,_originalWidth,_originalHeight);				//lineStyle(0,0x00FFFF,0.5);				//moveTo($x,0),lineTo($x,_originalHeight);				//moveTo(0,$y),lineTo(_originalWidth,$y);			}						if(!this.contains(_debugLayer)) this.addChild(_debugLayer); // attach		}				public function setAlign($type:String="TL"):void { _type = $type; }						public function smoothing($b:Boolean=true):void { _bitmap.smoothing = $b; }		public function offset($x:int,$y:int):void { this.x = $x, this.y = $y; }		//public function offsetBitmap($x:int,$y:int):void { _bitmap.x = $x, _bitmap.y = $y; }				// interface		public function dispose():void { _bitmapData.dispose(); }		public function getBitmapData():BitmapData { return _bitmapData; }		public function getBitmap():Bitmap { return _bitmap; }						public function erase():void { if(_bitmapData) _bitmapData.fillRect(_bitmapData.rect,0x00000000); }		public function draw($src:IBitmapDrawable,$matrix:Matrix=null):void { _bitmapData.draw($src,$matrix,null,null,null,true); }		public function copyPixels($src:BitmapData,$x:int,$y:int):void { _bitmapData.copyPixels($src,$src.rect,new Point($x,$y)); }	}};